ayAvailable: isUint8ArrayAvailable,
    isLatency: isLatency,
    sanitizeProperty: sanitizeProperty,
    getISOString: toISOString,
    useXDomainRequest: useXDomainRequest,
    getCommonSchemaMetaData: getCommonSchemaMetaData,
    cookieAvailable: areCookiesSupported,
    disallowsSameSiteNone: uaDisallowsSameSiteNone,
    setCookie: setCookie,
    deleteCookie: deleteCookie,
    getCookie: getCookie,
    createGuid: createGuid,
    extend: extend,
    getTime: getTime,
    isValueKind: isValueKind,
    isArrayValid: isArrayValid,
    objDefineAccessors: objDefineAccessors,
    addPageUnloadEventListener: addPageUnloadEventListener,
    setProcessTelemetryTimings: setProcessTelemetryTimings,
    addEventHandler: addEventHandler,
    getFieldValueType: getFieldValueType,
    strEndsWith: strEndsWith,
    objForEachKey: objForEachKey
};
var CoreUtils = {
    _canUseCookies: undefined,
    isTypeof: isTypeof,
    isUndefined: isUndefined,
    isNullOrUndefined: isNullOrUndefined,
    hasOwnProperty: hasOwnProperty,
    isFunction: isFunction,
    isObject: isObject,
    isDate: isDate,
    isArray: isArray,
    isError: isError,
    isString: isString,
    isNumber: isNumber,
    isBoolean: isBoolean,
    toISOString: toISOString,
    arrForEach: arrForEach,
    arrIndexOf: arrIndexOf,
    arrMap: arrMap,
    arrReduce: arrReduce,
    strTrim: strTrim,
    objCreate: objCreateFn,
    objKeys: objKeys,
    objDefineAccessors: objDefineAccessors,
    addEventHandler: addEventHandler,
    dateNow: dateNow,
    isIE: isIE,
    disableCookies: disableCookies,
    newGuid: newGuid,
    perfNow: perfNow,
    newId: newId,
    randomValue: randomValue,
    random32: random32,
    mwcRandomSeed: mwcRandomSeed,
    mwcRandom32: mwcRandom32,
    generateW3CId: generateW3CId
};
function isChromium() {
    return !!getGlobalInst("chrome");
}
function openXhr(method, urlString, withCredentials, disabled, isSync, timeout) {
    if (disabled === void 0) { disabled = false; }
    if (isSync === void 0) { isSync = false; }
    function _wrapSetXhrProp(xhr, prop, value) {
        try {
            xhr[prop] = value;
        }
        catch (e) {
        }
    }
    var xhr = new XMLHttpRequest();
    if (disabled) {
        _wrapSetXhrProp(xhr, strDisabledPropertyName, disabled);
    }
    if (withCredentials) {
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    xhr.open(method, urlString, !isSync);
    if (withCredentials) {
        _wrapSetXhrProp(xhr, strWithCredentials, withCredentials);
    }
    if (!isSync && timeout) {
        _wrapSetXhrProp(xhr, strTimeout, timeout);
    }
    return xhr;
}

var AppInsightsCore = /** @class */ (function (_super) {
    __extendsFn(AppInsightsCore, _super);
    function AppInsightsCore() {
        var _this = _super.call(this) || this;
        _this.pluginVersionStringArr = [];
        dynamicProto(AppInsightsCore, _this, function (_self, _base) {
            if (!_self.logger || !_self.logger.queue) {
                _self.logger = new DiagnosticLogger({ loggingLevelConsole: 1  });
            }
            _self.initialize = function (config, extensions, logger, notificationManager) {
                doPerf(_self, function () { return "AppInsightsCore.initialize"; }, function () {
                    var _pluginVersionStringArr = _self.pluginVersionStringArr;
                    if (config) {
                        if (!config.endpointUrl) {
                            config.endpointUrl = STR_DEFAULT_ENDPOINT_URL;
                        }
                        var propertyStorageOverride = config.propertyStorageOverride;
                        if (propertyStorageOverride && (!propertyStorageOverride.getProperty || !propertyStorageOverride.setProperty)) {
                            throwError("Invalid property storage override passed.");
                        }
                        if (config.channels) {
                            arrForEach(config.channels, function (channels) {
                                if (channels) {
                                    arrForEach(channels, function (channel) {
                                        if (channel.identifier && channel.version) {
                                            var ver = channel.identifier + "=" + channel.version;
                                            _pluginVersionStringArr.push(ver);
                                        }
                                    });
                                }
                            });
                        }
                    }
                    _self.getWParam = function () {
                        return (typeof document !== "undefined" || !!config.enableWParam) ? 0 : -1;
                    };
                    if (extensions) {
                        arrForEach(extensions, function (ext) {
                            if (ext && ext.identifier && ext.version) {
                                var ver = ext.identifier + "=" + ext.version;
                                _pluginVersionStringArr.push(ver);
                            }
                        });
                    }
                    _self.pluginVersionString = _pluginVersionStringArr.join(";");
                    _self.pluginVersionStringArr = _pluginVersionStringArr;
                    try {
                        _base.initialize(config, extensions, logger, notificationManager);
                        _self.pollInternalLogs("InternalLog");
                    }
                    catch (e) {
                        var logger_1 = _self.logger;
                        var message = dumpObj(e);
                        if (message.indexOf("channels") !== -1) {
                            message += "\n - Channels must be provided through config.channels only!";
                        }
                        _throwInternal(logger_1, 1 , 514 , "SDK Initialization Failed - no telemetry will be sent: " + message);
                    }
                }, function () { return ({ config: config, extensions: extensions, logger: logger, notificationManager: notificationManager }); });
            };
            _self.track = function (item) {
                doPerf(_self, function () { return "AppInsightsCore.track"; }, function () {
                    var telemetryItem = item;
                    if (telemetryItem) {
                        telemetryItem.timings = telemetryItem.timings || {};
                        telemetryItem.timings.trackStart = getTime();
                        if (!isLatency(telemetryItem.latency)) {
                            telemetryItem.latency = 1 ;
                        }
                        var itemExt = telemetryItem.ext = telemetryItem.ext || {};
                        itemExt.sdk = itemExt.sdk || {};
                        itemExt.sdk.ver = FullVersionString;
                        var baseData = telemetryItem.baseData = telemetryItem.baseData || {};
                        baseData[STR_PROPERTIES] = baseData[STR_PROPERTIES] || {};
                        var itemProperties = baseData[STR_PROPERTIES];
                        itemProperties[STR_VERSION] = itemProperties[STR_VERSION] || _self.pluginVersionString || STR_EMPTY;
                    }
                    _base.track(telemetryItem);
                }, function () { return ({ item: item }); }, !(item.sync));
            };
        });
        return _this;
    }
    AppInsightsCore.__ieDyn=1;
    return AppInsightsCore;
}(AppInsightsCore$2));
var AppInsightsCore$1 = AppInsightsCore;

var BaseCore = /** @class */ (function (_super) {
    __extendsFn(BaseCore, _super);
    function BaseCore() {
        var _this = _super.call(this) || this;
        dynamicProto(BaseCore, _this, function (_self, _base) {
            _self.initialize = function (config, extensions, logger, notificationManager) {
                if (config && !config.endpointUrl) {
                    config.endpointUrl = STR_DEFAULT_ENDPOINT_URL;
                }
                _self.getWParam = function () {
                    return (isDocumentObjectAvailable || !!config.enableWParam) ? 0 : -1;
                };
                try {
                    _base.initialize(config, extensions, logger, notificationManager);
                }
                catch (e) {
                    _throwInternal(_self.logger, 1 , 514 , "Initialization Failed: " + dumpObj(e) + "\n - Note: Channels must be provided through config.channels only");
                }
            };
            _self.track = function (item) {
                var telemetryItem = item;
                if (telemetryItem) {
                    var ext = telemetryItem.ext = telemetryItem.ext || {};
                    ext.sdk = ext.sdk || {};
                    ext.sdk.ver = FullVersionString;
                }
                _base.track(telemetryItem);
            };
        });
        return _this;
    }
    BaseCore.__ieDyn=1;
    return BaseCore;
}(BaseCore$2));
var BaseCore$1 = BaseCore;

var _isFunction = isFunction;
function _createPromiseAllOnResolvedFunction(values, index, resolvedCallback) {
    return function (value) {
        values[index] = value;
        resolvedCallback();
    };
}
var ESPromise = /** @class */ (function () {
    function ESPromise(resolverFunc) {
        var _state = 0 ;
        var _settledValue = null;
        var _queue = [];
        dynamicProto(ESPromise, this, function (_this) {
            _this.then = function (onResolved, onRejected) {
                return new ESPromise(function (resolve, reject) {
                    _enqueue(onResolved, onRejected, resolve, reject);
                });
            };
            _this["catch"] = function (onRejected) {
                return _this.then(null, onRejected);
            };
        });
        function _enqueue(onResolved, onRejected, resolve, reject) {
            _queue.push(function () {
                var value;
                try {
                    if (_state === 1 ) {
                        value = _isFunction(onResolved) ? onResolved(_settledValue) : _settledValue;
                    }
                    else {
                        value = _isFunction(onRejected) ? onRejected(_settledValue) : _settledValue;
                    }
                    if (value instanceof ESPromise) {
                        value.then(resolve, reject);
                    }
                    else if (_state === 2  && !_isFunction(onRejected)) {
                        reject(value);
                    }
                    else {
                        resolve(value);
                    }
                }
                catch (error) {
                    reject(error);
                    return;
                }
            });
            if (_state !== 0 ) {
                _processQueue();
            }
        }
        function _processQueue() {
            if (_queue.length > 0) {
                var pending_1 = _queue.slice();
                _queue = [];
                setTimeout(function () {
                    for (var i = 0, len = pending_1.length; i < len; ++i) {
                        try {
                            pending_1[i]();
                        }
                        catch (e) {
                        }
                    }
                }, 0);
            }
        }
        function _resolve(value) {
            if (_state === 0 ) {
                _settledValue = value;
                _state = 1 ;
                _processQueue();
            }
        }
        function _reject(reason) {
            if (_state === 0 ) {
                _settledValue = reason;
                _state = 2 ;
                _processQueue();
            }
        }
        (function _initialize() {
            if (!_isFunction(resolverFunc)) {
                throw new TypeError("ESPromise: resolvedFunc argument is not a Function");
            }
            try {
                resolverFunc(_resolve, _reject);
            }
            catch (error) {
                _reject(error);
            }
        })();
    }
    ESPromise.resolve = function (value) {
        if (value instanceof ESPromise) {
            return value;
        }
        else if (value && _isFunction(value.then)) {
            return new ESPromise(function (resolve, reject) {
                try {
                    value.then(resolve, reject);
                }
                catch (error) {
                    reject(error);
                }
            });
        }
        return new ESPromise(function (resolve) {
            resolve(value);
        });
    };
    ESPromise.reject = function (reason) {
        return new ESPromise(function (resolve, reject) {
            reject(reason);
        });
    };
    ESPromise.all = function (iterable) {
        if (!iterable || !iterable.length) {
            return;
        }
        return new ESPromise(function (resolve, reject) {
            try {
                var values_1 = [];
                var pending_2 = 0;
                for (var lp = 0; lp < iterable.length; lp++) {
                    var item = iterable[lp];
                    if (item && _isFunction(item.then)) {
                        pending_2++;
                        item.then(_createPromiseAllOnResolvedFunction(values_1, lp, function () {
                            if (--pending_2 === 0) {
                                resolve(values_1);
                            }
                        }), reject);
                    }
                    else {
                        values_1[lp] = item;
                    }
                }
                if (pending_2 === 0) {
                    setTimeout(function () {
                        resolve(values_1);
                    }, 0);
                }
            }
            catch (error) {
                reject(error);
            }
        });
    };
    ESPromise.race = function (iterable) {
        return new ESPromise(function (resolve, reject) {
            if (!iterable || !iterable.length) {
                return;
            }
            try {
                var _loop_1 = function (lp) {
                    var item = iterable[lp];
                    if (item && _isFunction(item.then)) {
                        item.then(resolve, reject);
                    }
                    else {
                        setTimeout(function () {
                            resolve(item);
                        }, 0);
                    }
                };
                for (var lp = 0; lp < iterable.length; lp++) {
                    _loop_1(lp);
                }
            }
            catch (error) {
                reject(error);
            }
        });
    };
    return ESPromise;
}());
var ESPromise$1 = ESPromise;

var LazyRejectPeriod = 600000;
var _schedulerId = 0;
var _running = [];
var _waiting = [];
var _timedOut = [];
function _getTime() {
    return new Date().getTime();
}
var ESPromiseScheduler = /** @class */ (function () {
    function ESPromiseScheduler(name, diagLog) {
        var _promiseId = 0;
        var _scheduledName = (name || "<unnamed>") + "." + _schedulerId;
        _schedulerId++;
        dynamicProto(ESPromiseScheduler, this, function (_this) {
            var _lastEvent = null;
            var _eventCount = 0;
            _this.scheduleEvent = function (startEventAction, eventName, timeout) {
                var uniqueId = _scheduledName + "." + _eventCount;
                _eventCount++;
                if (eventName) {
                    uniqueId += "-(" + eventName + ")";
                }
                var uniqueEventId = uniqueId + "{" + _promiseId + "}";
                _promiseId++;
                var newScheduledEvent = {
                    evt: null,
                    tm: _getTime(),
                    id: uniqueEventId,
                    isRunning: false,
                    isAborted: false
                };
                if (!_lastEvent) {
                    newScheduledEvent.evt = _startWaitingEvent(newScheduledEvent);
                }
                else {
                    newScheduledEvent.evt = _waitForPreviousEvent(newScheduledEvent, _lastEvent);
                }
                _lastEvent = newScheduledEvent;
                _lastEvent.evt._schId = uniqueEventId;
                return newScheduledEvent.evt;
                function _abortAndRemoveOldEvents(eventQueue) {
                    var now = _getTime();
                    var expired = now - LazyRejectPeriod;
                    var len = eventQueue.length;
                    var lp = 0;
                    while (lp < len) {
                        var evt = eventQueue[lp];
                        if (evt && evt.tm < expired) {
                            var message = null;
                            if (evt.abort) {
                                message = "Aborting [" + evt.id + "] due to Excessive runtime (" + (now - evt.tm) + " ms)";
                                evt.abort(message);
                            }
                            else {
                                message = "Removing [" + evt.id + "] due to Excessive runtime (" + (now - evt.tm) + " ms)";
                            }
                            _warnLog(message);
                            eventQueue.splice(lp, 1);
                            len--;
                        }
                        else {
                            lp++;
                        }
                    }
                }
                function _cleanup(eventId, completed) {
                    var toQueue = false;
                    var removed = _removeQueuedEvent(_running, eventId);
                    if (!removed) {
                        removed = _removeQueuedEvent(_timedOut, eventId);
                        toQueue = true;
                    }
                    if (removed) {
                        if (removed.to) {
                            clearTimeout(removed.to);
                            removed.to = null;
                        }
                        var tm = _getTime() - removed.tm;
                        if (completed) {
                            if (!toQueue) {
                                _debugLog("Promise [" + eventId + "] Complete -- " + tm + " ms");
                            }
                            else {
                                _warnLog("Timed out event [" + eventId + "] finally complete -- " + tm + " ms");
                            }
                        }
                        else {
                            _timedOut.push(removed);
                            _warnLog("Event [" + eventId + "] Timed out and removed -- " + tm + " ms");
                        }
                    }
                    else {
                        _debugLog("Failed to remove [" + eventId + "] from running queue");
                    }
                    if (_lastEvent && _lastEvent.id === eventId) {
                        _lastEvent = null;
                    }
                    _abortAndRemoveOldEvents(_running);
                    _abortAndRemoveOldEvents(_waiting);
                    _abortAndRemoveOldEvents(_timedOut);
                }
                function _removeScheduledEvent(eventId, callback) {
                    return function (value) {
                        _cleanup(eventId, true);
                        callback && callback(value);
                        return value;
                    };
                }
                function _waitForFinalResult(eventId, startResult, schEventResolve, schEventReject) {
                    startResult.then(function (value) {
                        if (value instanceof ESPromise$1) {
                            _debugLog("Event [" + eventId + "] returned a promise -- waiting");
                            _waitForFinalResult(eventId, value, schEventResolve, schEventReject);
                            return value;
                        }
                        else {
                            return _removeScheduledEvent(eventId, schEventResolve)(value);
                        }
                    }, _removeScheduledEvent(eventId, schEventReject));
                }
                function _createScheduledEvent(eventDetails, startEvent) {
                    var eventId = eventDetails.id;
                    return new ESPromise$1(function (schEventResolve, schEventReject) {
                        _debugLog("Event [" + eventId + "] Starting -- waited for " + (eventDetails.wTm || "--") + " ms");
                        eventDetails.isRunning = true;
                        eventDetails.abort = function (message) {
                            eventDetails.abort = null;
                            eventDetails.isAborted = true;
                            _cleanup(eventId, false);
                            schEventReject(new Error(message));
                        };
                        var startResult = startEvent(eventId);
                        if (startResult instanceof ESPromise$1) {
                            if (timeout) {
                                eventDetails.to = setTimeout(function () {
                                    _cleanup(eventId, false);
                                    schEventReject(new Error("Timed out after [" + timeout + "] ms"));
                                }, timeout);
                            }
                            _waitForFinalResult(eventId, startResult, function (theResult) {
                                _debugLog("Event [" + eventId + "] Resolving after " + (_getTime() - eventDetails.tm) + " ms");
                                schEventResolve(theResult);
                            }, schEventReject);
                        }
                        else {
                            _debugLog("Promise [" + eventId + "] Auto completed as the start action did not return a promise");
                            schEventResolve();
                        }
                    });
                }
                function _startWaitingEvent(eventDetails) {
                    var now = _getTime();
                    eventDetails.wTm = now - eventDetails.tm;
                    eventDetails.tm = now;
                    if (eventDetails.isAborted) {
                        return ESPromise$1.reject(new Error("[" + uniqueId + "] was aborted"));
                    }
                    _running.push(eventDetails);
                    return _createScheduledEvent(eventDetails, startEventAction);
                }
                function _waitForPreviousEvent(eventDetails, waitForEvent) {
                    var waitEvent = new ESPromise$1(function (waitResolve, waitReject) {
                        var runTime = _getTime() - waitForEvent.tm;
                        var prevId = waitForEvent.id;
                        _debugLog("[" + uniqueId + "] is waiting for [" + prevId + ":" + runTime + " ms] to complete before starting -- [" + _waiting.length + "] waiting and [" + _running.length + "] running");
                        eventDetails.abort = function (message) {
                            eventDetails.abort = null;
                            _removeQueuedEvent(_waiting, uniqueId);
                            eventDetails.isAborted = true;
                            waitReject(new Error(message));
                        };
                        waitForEvent.evt.then(function (value) {
                            _removeQueuedEvent(_waiting, uniqueId);
                            _startWaitingEvent(eventDetails).then(waitResolve, waitReject);
                        }, function (reason) {
                            _removeQueuedEvent(_waiting, uniqueId);
                            _startWaitingEvent(eventDetails).then(waitResolve, waitReject);
                        });
                    });
                    _waiting.push(eventDetails);
                    return waitEvent;
                }
            };
            function _removeQueuedEvent(queue, eventId) {
                for (var lp = 0; lp < queue.length; lp++) {
                    if (queue[lp].id === eventId) {
                        return queue.splice(lp, 1)[0];
                    }
                }
                return null;
            }
        });
        function _debugLog(message) {
            var global = getGlobal();
            if (global && global["QUnit"]) {
                console && console.log("ESPromiseScheduler[" + _scheduledName + "] " + message);
            }
        }
        function _warnLog(message) {
            _warnToConsole(diagLog, "ESPromiseScheduler[" + _scheduledName + "] " + message);
        }
    }
    ESPromiseScheduler.incomplete = function () {
        return _running;
    };
    ESPromiseScheduler.waitingToStart = function () {
        return _waiting;
    };
    return ESPromiseScheduler;
}());
var ESPromiseScheduler$1 = ESPromiseScheduler;

var ValueSanitizer = /** @class */ (function () {
    function ValueSanitizer(fieldSanitizerProvider) {
        var _self = this;
        var _sanitizerMap = {};
        var _sanitizers = [];
        var _fieldSanitizers = [];
        if (fieldSanitizerProvider) {
            _fieldSanitizers.push(fieldSanitizerProvider);
        }
        function _getFieldSanitizer(path, name) {
            var result;
            var fieldLookup = _sanitizerMap[path];
            if (fieldLookup) {
                result = fieldLookup[name];
            }
            if (!result && result !== null) {
                if (isString(path) && isString(name)) {
                    if (_fieldSanitizers.length > 0) {
                        for (var lp = 0; lp < _fieldSanitizers.length; lp++) {
                            if (_fieldSanitizers[lp].handleField(path, name)) {
                                result = {
                                    canHandle: true,
                                    fieldHandler: _fieldSanitizers[lp]
                                };
                                break;
                            }
                        }
                    }
                    else if (_sanitizers.length === 0) {
                        result = {
                            canHandle: true
                        };
                    }
                }
                if (!result && result !== null) {
                    result = null;
                    for (var lp = 0; lp < _sanitizers.length; lp++) {
                        if (_sanitizers[lp].handleField(path, name)) {
                            result = {
                                canHandle: true,
                                handler: _sanitizers[lp],
                                fieldHandler: null
                            };
                            break;
                        }
                    }
                }
                if (!fieldLookup) {
                    fieldLookup = _sanitizerMap[path] = {};
                }
                fieldLookup[name] = result;
            }
            return result;
        }
        _self.addSanitizer = function (newSanitizer) {
            if (newSanitizer) {
                _sanitizers.push(newSanitizer);
                _sanitizerMap = {};
            }
        };
        _self.addFieldSanitizer = function (fieldSanitizer) {
            if (fieldSanitizer) {
                _fieldSanitizers.push(fieldSanitizer);
                _sanitizerMap = {};
            }
        };
        _self.handleField = function (path, name) {
            var mapValue = _getFieldSanitizer(path, name);
            return mapValue ? mapValue.canHandle : false;
        };
        _self.value = function (path, name, value, stringifyObjects) {
            var mapValue = _getFieldSanitizer(path, name);
            if (mapValue && mapValue.canHandle) {
                if (!mapValue || !mapValue.canHandle) {
                    return null;
                }
                if (mapValue.handler) {
                    return mapValue.handler.value(path, name, value, stringifyObjects);
                }
                if (!isString(name) || isNullOrUndefined(value) || value === STR_EMPTY) {
                    return null;
                }
                var property = null;
                var fieldType = getFieldValueType(value);
                if ((fieldType & 8192 ) === 8192 ) {
                    var subType = fieldType & ~8192 ;
                    property = value;
                    if (!isValueAssigned(property.value) ||
                        (subType !== 1  &&
                            subType !== 2  &&
                            subType !== 3  &&
                            (subType & 4096 ) !== 4096 )) {
                        return null;
                    }
                }
                else if (fieldType === 1  ||
                    fieldType === 2  ||
                    fieldType === 3  ||
                    (fieldType & 4096 ) === 4096 ) {
                    property = _convertToProperty(path, name, value);
                }
                else if (fieldType === 4 ) {
                    property = _convertToProperty(path, name, !!stringifyObjects ? JSON.stringify(value) : value);
                }
                if (property) {
                    return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
                }
            }
            return null;
        };
        _self.property = function (path, name, property, stringifyObjects) {
            var mapValue = _getFieldSanitizer(path, name);
            if (!mapValue || !mapValue.canHandle) {
                return null;
            }
            if (!isString(name) || isNullOrUndefined(property) || !isValueAssigned(property.value)) {
                return null;
            }
            var fieldType = getFieldValueType(property.value);
            if (fieldType === 0 ) {
                return null;
            }
            return _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects);
        };
        function _handleProperty(mapValue, path, name, fieldType, property, stringifyObjects) {
            if (mapValue.handler) {
                return mapValue.handler.property(path, name, property, stringifyObjects);
            }
            if (!isNullOrUndefined(property.kind)) {
                if ((fieldType & 4096 ) === 4096  || !isValueKind(property.kind)) {
                    return null;
                }
                property.value = property.value.toString();
            }
            return _callFieldSanitizer(mapValue.fieldHandler, path, name, fieldType, property);
        }
        function _convertToProperty(path, name, value) {
            if (isValueAssigned(value)) {
                return { value: value };
            }
            return null;
        }
        function _callFieldSanitizer(fieldProvider, path, name, theType, property) {
            if (property && fieldProvider) {
                var sanitizer = fieldProvider.getSanitizer(path, name, theType, property.kind, property.propertyType);
                if (sanitizer) {
                    if (theType === 4 ) {
                        var newValue_1 = {};
                        var propValue = property.value;
                        objForEachKey(propValue, function (propKey, theValue) {
                            var newPath = path + "." + name;
                            if (isValueAssigned(theValue)) {
                                var newProp = _convertToProperty(newPath, propKey, theValue);
                                newProp = _callFieldSanitizer(fieldProvider, newPath, propKey, getFieldValueType(theValue), newProp);
                                if (newProp) {
                                    newValue_1[propKey] = newProp.value;
                                }
                            }
                        });
                        property.value = newValue_1;
                    }
                    else {
                        var details = {
                            path: path,
                            name: name,
                            type: theType,
                            prop: property,
                            sanitizer: _self
                        };
                        property = sanitizer.call(_self, details);
                    }
                }
            }
            return property;
        }
    }
    ValueSanitizer.getFieldType = getFieldValueType;
    return ValueSanitizer;
}());

exports.AppInsightsCore = AppInsightsCore$1;
exports.BaseCore = BaseCore$1;
exports.BaseTelemetryPlugin = BaseTelemetryPlugin;
exports.CoreUtils = CoreUtils;
exports.DiagnosticLogger = DiagnosticLogger;
exports.ESPromise = ESPromise$1;
exports.ESPromiseScheduler = ESPromiseScheduler$1;
exports.EventHelper = EventHelper;
exports.EventLatency = EventLatency;
exports.EventPersistence = EventPersistence;
exports.EventPropertyType = EventPropertyType;
exports.EventsDiscardedReason = EventsDiscardedReason;
exports.FullVersionString = FullVersionString;
exports.InternalAppInsightsCore = AppInsightsCore$2;
exports.InternalBaseCore = BaseCore$2;
exports.LoggingSeverity = LoggingSeverity;
exports.MinChannelPriorty = MinChannelPriorty;
exports.NotificationManager = NotificationManager;
exports.PerfEvent = PerfEvent;
exports.PerfManager = PerfManager;
exports.ProcessTelemetryContext = ProcessTelemetryContext;
exports.TraceLevel = TraceLevel;
exports.Undefined = strShimUndefined;
exports.Utils = Utils;
exports.ValueKind = ValueKind;
exports.ValueSanitizer = ValueSanitizer;
exports.Version = Version;
exports._ExtendedInternalMessageId = _ExtendedInternalMessageId;
exports._InternalLogMessage = _InternalLogMessage;
exports._InternalMessageId = _InternalMessageId;
exports.__getRegisteredEvents = __getRegisteredEvents;
exports._logInternalMessage = _logInternalMessage;
exports._throwInternal = _throwInternal;
exports._warnToConsole = _warnToConsole;
exports.addEventHandler = addEventHandler;
exports.addEventListeners = addEventListeners;
exports.addPageHideEventListener = addPageHideEventListener;
exports.addPageShowEventListener = addPageShowEventListener;
exports.addPageUnloadEventListener = addPageUnloadEventListener;
exports.areCookiesSupported = areCookiesSupported;
exports.arrForEach = arrForEach;
exports.arrIndexOf = arrIndexOf;
exports.arrMap = arrMap;
exports.arrReduce = arrReduce;
exports.attachEvent = attachEvent;
exports.cookieAvailable = areCookiesSupported;
exports.createCookieMgr = createCookieMgr;
exports.createEnumStyle = createEnumStyle;
exports.createGuid = createGuid;
exports.createProcessTelemetryContext = createProcessTelemetryContext;
exports.createTraceParent = createTraceParent;
exports.createUniqueNamespace = createUniqueNamespace;
exports.createUnloadHandlerContainer = createUnloadHandlerContainer;
exports.dateNow = dateNow;
exports.deleteCookie = deleteCookie;
exports.detachEvent = detachEvent;
exports.disableCookies = disableCookies;
exports.disallowsSameSiteNone = uaDisallowsSameSiteNone;
exports.doPerf = doPerf;
exports.dumpObj = dumpObj;
exports.eventOff = eventOff;
exports.eventOn = eventOn;
exports.extend = extend;
exports.findW3cTraceParent = findW3cTraceParent;
exports.formatTraceParent = formatTraceParent;
exports.generateW3CId = generateW3CId;
exports.getCommonSchemaMetaData = getCommonSchemaMetaData;
exports.getConsole = getConsole;
exports.getCookie = getCookie;
exports.getCookieValue = getCookieValue;
exports.getCrypto = getCrypto;
exports.getDocument = getDocument;
exports.getExceptionName = getExceptionName;
exports.getFieldValueType = getFieldValueType;
exports.getGlobal = getGlobal;
exports.getGlobalInst = getGlobalInst;
exports.getHistory = getHistory;
exports.getIEVersion = getIEVersion;
exports.getISOString = toISOString;
exports.getJSON = getJSON;
exports.getLocation = getLocation;
exports.getMsCrypto = getMsCrypto;
exports.getNavigator = getNavigator;
exports.getPerformance = getPerformance;
exports.getSetValue = getSetValue;
exports.getTenantId = getTenantId;
exports.getTime = getTime;
exports.getWindow = getWindow;
exports.hasDocument = hasDocument;
exports.hasHistory = hasHistory;
exports.hasJSON = hasJSON;
exports.hasNavigator = hasNavigator;
exports.hasOwnProperty = hasOwnProperty;
exports.hasWindow = hasWindow;
exports.isArray = isArray;
exports.isArrayValid = isArrayValid;
exports.isBeaconsSupported = isBeaconsSupported;
exports.isBoolean = isBoolean;
exports.isChromium = isChromium;
exports.isDate = isDate;
exports.isDocumentObjectAvailable = isDocumentObjectAvailable;
exports.isError = isError;
exports.isFetchSupported = isFetchSupported;
exports.isFunction = isFunction;
exports.isIE = isIE;
exports.isLatency = isLatency;
exports.isNotTruthy = isNotTruthy;
exports.isNullOrUndefined = isNullOrUndefined;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isReactNative = isReactNative;
exports.isSampledFlag = isSampledFlag;
exports.isString = isString;
exports.isTruthy = isTruthy;
exports.isTypeof = isTypeof;
exports.isUint8ArrayAvailable = isUint8ArrayAvailable;
exports.isUndefined = isUndefined;
exports.isValidSpanId = isValidSpanId;
exports.isValidTraceId = isValidTraceId;
exports.isValidTraceParent = isValidTraceParent;
exports.isValueAssigned = isValueAssigned;
exports.isValueKind = isValueKind;
exports.isWindowObjectAvailable = isWindowObjectAvailable;
exports.isXhrSupported = isXhrSupported;
exports.mergeEvtNamespace = mergeEvtNamespace;
exports.newGuid = newGuid;
exports.newId = newId;
exports.normalizeJsName = normalizeJsName;
exports.objCreate = objCreateFn;
exports.objDefineAccessors = objDefineAccessors;
exports.objForEachKey = objForEachKey;
exports.objFreeze = objFreeze;
exports.objKeys = objKeys;
exports.objSeal = objSeal;
exports.openXhr = openXhr;
exports.optimizeObject = optimizeObject;
exports.parseTraceParent = parseTraceParent;
exports.perfNow = perfNow;
exports.proxyAssign = proxyAssign;
exports.proxyFunctionAs = proxyFunctionAs;
exports.proxyFunctions = proxyFunctions;
exports.random32 = random32;
exports.randomValue = randomValue;
exports.removeEventHandler = removeEventHandler;
exports.removeEventListeners = removeEventListeners;
exports.removePageHideEventListener = removePageHideEventListener;
exports.removePageShowEventListener = removePageShowEventListener;
exports.removePageUnloadEventListener = removePageUnloadEventListener;
exports.safeGetCookieMgr = safeGetCookieMgr;
exports.safeGetLogger = safeGetLogger;
exports.sanitizeProperty = sanitizeProperty;
exports.setCookie = setCookie;
exports.setEnableEnvMocks = setEnableEnvMocks;
exports.setProcessTelemetryTimings = setProcessTelemetryTimings;
exports.setValue = setValue;
exports.strContains = strContains;
exports.strEndsWith = strEndsWith;
exports.strFunction = strShimFunction;
exports.strObject = strShimObject;
exports.strPrototype = strShimPrototype;
exports.strStartsWith = strStartsWith;
exports.strTrim = strTrim;
exports.strUndefined = strShimUndefined;
exports.throwError = throwError;
exports.toISOString = toISOString;
exports.useXDomainRequest = useXDomainRequest;

}));
